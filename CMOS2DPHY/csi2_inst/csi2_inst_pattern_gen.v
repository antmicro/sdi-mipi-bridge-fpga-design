//===========================================================================
// Verilog file generated by Clarity Designer    08/05/2020    12:44:46  
// Filename  : csi2_inst_pattern_gen.v                                                
// IP package: CMOS to D-PHY 1.3                           
// Copyright(c) 2016 Lattice Semiconductor Corporation. All rights reserved. 
//===========================================================================

module csi2_inst_pattern_gen #(
    parameter H_ACTIVE      = 'd1920     ,
    parameter H_TOTAL       = 'd2200     ,
    parameter V_ACTIVE      = 'd1080     ,
    parameter V_TOTAL       = 'd1125     ,
    parameter H_SYNCH       =   'd44     ,
    parameter H_BACK_PORCH  =  'd148     ,
    parameter H_FRONT_PORCH =   'd88     ,
    parameter V_SYNCH       =    'd5     ,
    parameter V_BACK_PORCH  =   'd36     ,
    parameter V_FRONT_PORCH =    'd4     ,
    parameter MODE          =      1     // 0 = colorbar, 1 = incrementing
) (
    input			reset_n,
    input			clk,
    input			start_i,

    // DPI format
    output reg			vsync_o,
    output reg			hsync_o,
    output reg			de_o,
    output reg [23:0] 		data_o,

    // CSI format
    output reg			fv_o,
    output reg			lv_o
);





    localparam H_ACTIVE_NEW = H_ACTIVE;

  
    localparam H_TOTAL_NEW = H_ACTIVE_NEW;

    localparam V_ACTIVE_DIV4 = V_ACTIVE/4;

    localparam  BLUE    = 24'hFF0000;
    localparam  GREEN   = 24'h00FF00;
    localparam  RED     = 24'h0000FF;
    localparam  WHITE   = 24'hFFFFFF;

    // registers
    reg			vsync_c;
    reg			hsync_c;
    reg			de_c;
    reg [23:0]		data_c;
    reg			fv_c, fv_r;
    reg			lv_c, lv_r;
    reg [7:0]		rstn_cnt_r;
    reg [11:0] 		pixcnt_r, pixcnt_c;
    reg [11:0]		linecnt_r, linecnt_c;
    reg [11:0]          act_linecnt_r, act_linecnt_c;
    reg [9:0]		color_cnt_r, color_cnt_c;
    reg                 lv_delay, fv_delay;
    reg [7:0]           lv_delay_cnt, fv_extend_cnt;

    // sequential block
    always @(posedge clk or negedge reset_n) begin 
        if (!reset_n) begin
	    rstn_cnt_r		<= 0;
        end
        else begin
	    rstn_cnt_r		<= rstn_cnt_r[7] ? rstn_cnt_r : rstn_cnt_r+1;
	end	
    end

    always @(posedge clk or negedge rstn_cnt_r[7])
	if (!rstn_cnt_r[7]) begin
	   vsync_o		<= 0;
	   hsync_o		<= 0;
	   de_o			<= 0;
	   data_o		<= 0;
	   fv_o			<= 0;
	   lv_o			<= 0;
	   pixcnt_r		<= 0;
	   linecnt_r		<= 0;
	   color_cnt_r		<= 0;
           act_linecnt_r        <= 0;
           fv_r                 <= 0;
           lv_r                 <= 0;
	end
	else if (start_i) begin
	   vsync_o		<= vsync_c;
	   hsync_o		<= hsync_c;
	   de_o			<= de_c;
	   data_o		<= data_c;
	   fv_r			<= fv_c;
	   lv_r			<= lv_c;
           fv_o                 <= fv_r || fv_c;
           lv_o                 <= lv_r || lv_c;
	   pixcnt_r		<= pixcnt_c;
	   linecnt_r		<= linecnt_c;
	   color_cnt_r		<= color_cnt_c;
           act_linecnt_r        <= act_linecnt_c;
   	end

  always @(posedge clk or negedge rstn_cnt_r[7])
        if (!rstn_cnt_r[7]) begin
          lv_delay_cnt <= 0;
          lv_delay <= 0;
        end
        else if (lv_delay_cnt == 'hE0) begin
          lv_delay_cnt <= 0;
          lv_delay <=0;
        end
        else if (fv_c  && !lv_c && !fv_delay) begin
          lv_delay_cnt <= lv_delay_cnt + 1;
          lv_delay <= 1;
        end

  always @(posedge clk or negedge rstn_cnt_r[7])
    if (!rstn_cnt_r[7]) begin
          fv_extend_cnt <= 0;
          fv_delay <= 0;
        end
    else if (fv_extend_cnt == 'hE0) begin
       fv_extend_cnt <= 0 ;
       fv_delay <= 0;
    end
    else if ((linecnt_c == V_ACTIVE) && (pixcnt_c == H_ACTIVE_NEW-1)) begin
       fv_extend_cnt <= fv_extend_cnt + 1 ;
       fv_delay <= 1;
    end	

    // Combinational block
    always @(*) begin

        pixcnt_c	= lv_delay ? 0: fv_delay ? pixcnt_r: (pixcnt_r < H_TOTAL_NEW-1) ? pixcnt_r+1 : 0;
        linecnt_c       = (lv_delay || fv_delay) ? linecnt_r: ((linecnt_r < V_TOTAL-1) && (pixcnt_r == H_TOTAL_NEW-1)) ? linecnt_r + 1:
                          ((linecnt_r == V_TOTAL-1) && (pixcnt_r == H_TOTAL_NEW-1)) ? 0 : linecnt_r;

	lv_c		= (pixcnt_c > 0 && pixcnt_c <= H_ACTIVE_NEW) && (linecnt_c > 0 && linecnt_c <= V_ACTIVE) && !fv_delay;
	fv_c		= (linecnt_c > 0 && linecnt_c <= V_ACTIVE) || lv_delay || fv_delay ;

        color_cnt_c	= lv_r ? color_cnt_r+1 : 0; 

	if (MODE) begin // Incrementing data
//	    data_c 	= {8'h80+color_cnt_r[7:0], 8'h40+color_cnt_r[7:0], 8'h10+color_cnt_r[7:0]};
	            data_c 	= {8'h00+color_cnt_r[7:0], 8'h00+color_cnt_r[7:0], 8'h00+color_cnt_r[7:0]};
	end
	else begin  // color bar
//	    data_c	= (color_cnt_r < (V_ACTIVE/3)) ? {8'hFF, 8'h00, 8'h00} :
//		          (color_cnt_r < ((V_ACTIVE/3)*2)) ? {8'h00, 8'hFF, 8'h00} : {8'h00, 8'h00, 8'hFF};
            if (act_linecnt_r >= 0 && act_linecnt_r <= V_ACTIVE_DIV4 - 1) begin
                data_c = RED;
            end
            else if (act_linecnt_r >= V_ACTIVE_DIV4 && act_linecnt_r <= V_ACTIVE_DIV4*2 - 1) begin
                data_c = GREEN;
            end
            else if (act_linecnt_r >= V_ACTIVE_DIV4*2 && act_linecnt_r <= V_ACTIVE_DIV4*3 - 1) begin
                data_c = BLUE;
            end
            else begin
                data_c = WHITE;
            end

	end
    end

endmodule
