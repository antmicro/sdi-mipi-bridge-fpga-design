//===========================================================================
// Verilog file generated by Clarity Designer    07/02/2020    13:15:17  
// Filename  : csi2_inst_cmos_2_dphy_ip.v                                                
// IP package: CMOS to D-PHY 1.3                           
// Copyright(c) 2016 Lattice Semiconductor Corporation. All rights reserved. 
//===========================================================================
`timescale 1ns/1ps

module csi2_inst_cmos_2_dphy_ip #(
//-----------------------------------
// Added for HS Blanking Support
  parameter PKTHDR_FIFO_IMPL = "EBR",       // Enable HS Blanking packet
  parameter HSBLP_EN = 1'b0,       // Enable HS Blanking packet
  parameter HSBLP_LOOP_EN = 1'b1,    // Enable HS Blanking packet
  parameter WC_HSA = 16'd512,       // Horizontal Sync Active Blanking packet
  parameter WC_HFP = 16'd256,        // Horizontal Front Porch Blanking packet
  parameter WC_HBP = 16'd512,       // Horizontal Back Porch Blanking packet
  parameter HFP_CHKSUM = 16'h70F7,       // Horizontal Back Porch Blanking packet
  parameter HBP_CHKSUM = 16'h8209,       // Horizontal Back Porch Blanking packet
//-----------------------------------
////added support for HS_ONLY mode
  parameter CLK_MODE = "HS_ONLY",
////added disable tinit count
  parameter TINIT_COUNT = "ON",

  parameter  VC              = 2,           // 2-bit Virtual channel number
  parameter  WC              = 16'd36,	    // 16-bit Word Count in DPHY packet
  parameter  CRC16           = 1,           // Appends 16-bit checksum to the end of packet.  
                                            // 0 = off, 1 = on by default. CRC is always set to 1.
                                            // Turning off will append 16'hFFFF to end of packet.
  parameter  DATA_WIDTH      = 16,          // Internally used. Always set to 16.              
  parameter  TINIT_VALUE     = 1000,        // Specify time for the DPHY Tinit requirement. 
                                            // This is dependent on byte clock
  parameter  ROM_WAIT_TIME   = 200,         // Specify delay time for sending DCS commands. 
                                            // This is dependent on DCS clock.
  parameter  CN              = 5'b11100,    // Tx PLL Input Divider
                                            // (25 <= pix_clk/N <= 30)  
  parameter  CM              = 8'b11101110, // Tx PLL Feedback Divider
                                            // (640 <= (pix_clk/(N*O))*M) <= 1500)                 
  parameter  CO              = 2'b00,       // Tx PLL Output Divider
                                            // Refer to Mixel PLL Specs for valid values
  parameter  TX_FREQ_TGT     = 8'd112,      // Set the target Tx byte clock which is used by DPHY TX.
                                            // Setting this parameter does not mean that design will
                                            // output the specified byte clock. This is just used as a
                                            // reference value inside the design.
  parameter  LPHS_FIFO_IMPL  = "LUT",	    // LP_HS_dly_ctrl fifo implementation "EBR"|"LUT"		 											
  parameter	LANE_WIDTH       = 2,

  parameter	NUM_PIX_LANE	 = 1,

  parameter	GEAR_16         = 0,            // 8:1 gearing


  parameter DSI_FORMAT      = 0,
  parameter EOTP            = 1'b0,
  parameter FILTER_1STLINE  = 0,

  parameter DT              = 6'h24,
  parameter WORD_WIDTH      = 24,

// Internally used only. Not a soft IP feature.
// Used for debugging purposes. Used to set parameters for color bar generator.
  parameter TESTMODE        = 0
)
(
////added ports for handshaking between Rx/bridge and Tx
  input clk_hs_en_i,
  input d_hs_en_i,
  output d_hs_rdy_o,
  output wire d_hs_en_o,

  input                      reset_n_i,     // (active low) asynchronous reset
  input                      pix_clk_i,     // pixel clock

////Added separate port for Mixel PLL refclk, and Snow PLL lock
  input                      ref_clk_i,     // Mixel PLL refclk
  input                      pll_lock_i,    // Snow PLL lock
  
  output                     byte_clk_o,    // byte clock from DPHY
  output                     pll_lock_o,    // PLL clock lock signal
  output                     tinit_done_o,  // Tinit done
  
  input                      core_clk_i,    // core clock 
  input                      pd_dphy_i,     // DPHY PD signal



  input                      fv_i,          // frame valid input for CMOS i/f
  input                      lv_i,          // line valid input for CMOS i/f
  input                      dvalid_i,      // data valid
  input [WORD_WIDTH-1:0]     pixdata_d0_i,

  // DPHY Ports
  inout                      clk_p_o,
  inout                      clk_n_o,
  inout                      d0_p_io,
  inout                      d0_n_io,
  inout                      d1_p_o,
  inout                      d1_n_o,

// Debug ports
  output                     fv_start_o,
  output                     lv_start_o,
  output                     c2d_ready_o,
  output                     hs_clk_gate_en_o,
  output                     hs_clk_en_o,
  output                     lp_clk_en_o,
  output                     dphy_pkten_o,
  output                     byte_data_en_o					
);

// wires
wire [4*DATA_WIDTH-1:0]      byte_data_w;
wire [5:0]                   data_type_w;		
wire [15:0]                  chksum_w;
wire [4*DATA_WIDTH-1:0]      dphy_pkt_w;
wire [DATA_WIDTH-1:0]        hs_data_d3_w;
wire [DATA_WIDTH-1:0]        hs_data_d2_w;
wire [DATA_WIDTH-1:0]        hs_data_d1_w;
wire [DATA_WIDTH-1:0]        hs_data_d0_w;

wire                         vsync_w, vsync_gen_w;
wire                         hsync_w, hsync_gen_w;
wire                         de_w, de_gen_w;
wire [23:0]                  data_gen_w;
wire                         fv_w, fv_gen_w;
wire                         lv_w, lv_gen_w;

wire [WORD_WIDTH-1:0]        pixdata_d9_w;
wire [WORD_WIDTH-1:0]        pixdata_d8_w;
wire [WORD_WIDTH-1:0]        pixdata_d7_w;
wire [WORD_WIDTH-1:0]        pixdata_d6_w;
wire [WORD_WIDTH-1:0]        pixdata_d5_w;
wire [WORD_WIDTH-1:0]        pixdata_d4_w;
wire [WORD_WIDTH-1:0]        pixdata_d3_w;
wire [WORD_WIDTH-1:0]        pixdata_d2_w;
wire [WORD_WIDTH-1:0]        pixdata_d1_w;
wire [WORD_WIDTH-1:0]        pixdata_d0_w;

////added for NUM_PIX_LANE_2
reg  [WORD_WIDTH-1:0]        pixdata_d1_r;
reg  [WORD_WIDTH-1:0]        pixdata_d0_r;
reg                          pixdata_shift_en;

wire                         hs_clk_gate_en_w;
wire                         hs_clk_en_w;
wire                         lp_clk_en_w;
wire                         dphy_pkten_w;
wire                         byte_data_en_w;
wire                         vsync_start_w;
wire                         hsync_start_w;
wire                         fv_start_w;
wire                         lv_start_w;

wire                         start_ptrn_gen;  // Internally used to start pattern_gen module.
                                              // For debugging purposes only.
wire                         pix2byte_rstn_w;
wire [7:0]                   data_w;

wire                         odd_line_w;

wire [1:0]                   yuv420_wc;

wire                         c2d_ready_w;

// Wires for HS_DCS Support
wire done_dcs_crtl_w;
wire dphy_pkten_frmtr_w;
wire [4*DATA_WIDTH-1:0] dphy_pkt_frmtr_w;
wire done_w;

//prevents undeclared identifier compile error

// Mapping of data when HS_DCS is selected

////added wire to define start of LP->HS transition during HS_ONLY and HS_LP modes
wire clk_hs_en;

// Debug ports
assign hs_clk_gate_en_o = hs_clk_gate_en_w;
assign hs_clk_en_o      = hs_clk_en_w;
assign lp_clk_en_o      = lp_clk_en_w;
assign dphy_pkten_o     = dphy_pkten_w;
assign byte_data_en_o   = byte_data_en_w;

// Word count tracker for YUV420 data type for CSI2
// WC is twice for even lines compare to odd lines
assign yuv420_wc = (odd_line_w) ? 1 : 2;

///////////////////////////////////////////////////////////////
// Synchronize reset input to different clock domain
//////////////////////////////////////////////////////////////
////add reset for refclk
wire ref_rstn;
wire pix_rstn;
wire core_rstn;
csi2_inst_synchronizer sync_u0 (.clk(core_clk_i), .rstn(reset_n_i), .in(reset_n_i & pll_lock_o), .out(core_rstn)); 
csi2_inst_synchronizer sync_u1 (.clk(pix_clk_i), .rstn(reset_n_i), .in(reset_n_i), .out(pix_rstn)); 
////reset Mixel until Snow PLL lock is detected. If Snow PLL is not used, PLL lock input is tied to 1.
csi2_inst_synchronizer sync_u2 (.clk(ref_clk_i), .rstn(reset_n_i), .in(reset_n_i & pll_lock_i), .out(ref_rstn));

// Data mapping for HS_DCS Support
assign dphy_pkten_w = dphy_pkten_frmtr_w;
assign dphy_pkt_w   = dphy_pkt_frmtr_w;


// Debug ports
  assign fv_start_o = fv_start_w;
  assign lv_start_o = lv_start_w;

assign c2d_ready_o = (tinit_done_o) ? c2d_ready_w : tinit_done_o; 

  assign fv_w         = fv_i;
  assign lv_w         = lv_i;
  assign pixdata_d0_w = pixdata_d0_i[WORD_WIDTH-1:0];

///////////////////////////////////////////////////////////////
   // align pixel data for NUM_PIX_LANE_2 case
   // align by shifting D1 to D0 position in next clock cycle, 
   // and D0 to D1 position of current clock cycle
///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
   // pixel2byte instance
///////////////////////////////////////////////////////////////
csi2_inst_pixel2byte pixel2byte_inst (
////added ports for handshaking with LP HS controller
  .d_hs_rdy_i    (d_hs_rdy_o),
  .d_hs_en_o     (d_hs_en_o),

  // clock and reset
  .pix_clk       (pix_clk_i),
  .core_clk      (core_clk_i),
  .reset_n       (reset_n_i & pix2byte_rstn_w),
  .pix_rstn      (pix_rstn & pix2byte_rstn_w), 

  .fv_i          (fv_w),          // frame valid input for CMOS i/f
  .lv_i          (lv_w),          // line valid input for CMOS i/f
  .dvalid_i      (dvalid_i),      // data valid
  .pixdata_d0_i  (pixdata_d0_w),

  // DPHY data width for RGB and RAW
  .byte_data_en_o (byte_data_en_w),
  .byte_data_o    (byte_data_w),	
  .data_type_o    (data_type_w),

  // Frame format for RGB
  .fv_start_o     (fv_start_w),
  .fv_end_o       (fv_end_w),
  .lv_start_o     (lv_start_w),
  .lv_end_o       (lv_end_w),
  .odd_line_o     (odd_line_w)
);


///////////////////////////////////////////////////////////////
// packet formatter instance
///////////////////////////////////////////////////////////////
csi2_inst_pkt_formatter pkt_formatter_inst (
//-----------------------------------
// Added for HS Blanking Support
  .hsblp_en_i       (HSBLP_EN),
  .hsblp_loop_en_i  (HSBLP_LOOP_EN),
  .wc_hsa_i         (WC_HSA),
  .wc_hfp_i         (WC_HFP),
  .wc_hbp_i         (WC_HBP),
  .hfp_chksum_i     (HFP_CHKSUM),
  .hbp_chksum_i     (HBP_CHKSUM),
//-----------------------------------
  // clock and reset
  .reset_n        (core_rstn),
  .core_clk       (core_clk_i),
  
  // packet settings
  .vc_i           (VC),
  .dt_i           (data_type_w),
  .wc_i           (WC),
  .eotp_i         (EOTP),

  // control/data from pixel2byte
  .fv_start_i     (fv_start_w),
  .fv_end_i       (fv_end_w),
  .lv_start_i     (lv_start_w),
  .lv_end_i       (lv_end_w),
  
  .byte_data_i    (byte_data_w),
  .byte_data_en_i (byte_data_en_w),
  
  .pix2byte_rstn_o (pix2byte_rstn_w),
  .dphy_pkt_o      (dphy_pkt_frmtr_w),
  .dphy_pkten_o    (dphy_pkten_frmtr_w)
);

///////////////////////////////////////////////////////////////
// tx_global_operation instance
///////////////////////////////////////////////////////////////
generate 
  if (CLK_MODE=="HS_ONLY") begin: gen_clk_hs_en_hs
    assign clk_hs_en = done_w;
  end
  else begin
    assign clk_hs_en = clk_hs_en_i;
  end
endgenerate 

csi2_inst_tx_global_operation tx_global_operation_inst (
////added ports for handshaking with Rx/bridge/pixel2byte
  .clk_hs_en_i (clk_hs_en),
  .d_hs_en_i   (d_hs_en_i),
  .d_hs_rdy_o  (d_hs_rdy_o),

  // clock and reset
  .reset_n     (core_rstn),
  .core_clk    (core_clk_i),
  
  .dphy_pkten_i (dphy_pkten_w),
  .dphy_pkt_i   (dphy_pkt_w),

  // interface to DCI wrapper
  // HS i/f
  .hs_clk_gate_en_o (hs_clk_gate_en_w),
  .hs_clk_en_o      (hs_clk_en_w),
  .hs_data_en_o     (hs_data_en_w),
  .hs_data_d1_o     (hs_data_d1_w),
  .hs_data_d0_o     (hs_data_d0_w),

  .c2d_ready_o      (c2d_ready_w),
  
  // LP i/f
  .lp_clk_en_o      (lp_clk_en_w),
  .lp_clk_p_o       (lp_clk_p_w),
  .lp_clk_n_o       (lp_clk_n_w),
  .lp_data_en_o     (lp_data_en_w),
  .lp_data_p_o      (lp_data_p_w),
  .lp_data_n_o      (lp_data_n_w)
);

//-----------------------------------------------------------------
// Mixel DPHY instance
// Using HW model for now
//-----------------------------------------------------------------
wire lp_data_dcs_p_w;
wire lp_data_dcs_n_w;
wire dcs_lp_w;
wire dcs_ln_w;


assign lp_data_dcs_p_w = done_w ? lp_data_p_w : 1'b1;
assign lp_data_dcs_n_w = done_w ? lp_data_n_w : 1'b1;

///////////////////////////////////////////////////////////////
// dci_wrapper instance
///////////////////////////////////////////////////////////////
csi2_inst_dci_wrapper dci_wrapper_inst   (
  // clock and reset
////separate refclk from pix_clk to add option to use Snow PLL
  .refclk          (ref_clk_i),
////change to reset for refclk
  .reset_n         (ref_rstn),
  
  // MIPI interface signals
  .clk_p_o         (clk_p_o),
  .clk_n_o         (clk_n_o),
  .d1_p_o          (d1_p_o),
  .d1_n_o          (d1_n_o),
  .d0_p_io         (d0_p_io),
  .d0_n_io         (d0_n_io),

  // high-speed transmit signals
  .txbyte_clkhs_o  (byte_clk_o),
  .pll_lock_o      (pll_lock_o),
  
  .txclk_hsen_i   (hs_clk_en_w & done_w), 
  .txclk_hsgate_i  (hs_clk_gate_en_w),
  .pd_dphy_i       (pd_dphy_i),

  .dl1_txdata_hs_i    (hs_data_d1_w),
  .dl0_txdata_hs_i    (hs_data_d0_w),
  .dl1_txdata_hs_en_i (hs_data_en_w & done_w),
  .dl0_txdata_hs_en_i (hs_data_en_w & done_w),

  // low-power transmit signals
  .txclk_lp_p_i       (done_w ? lp_clk_p_w : 1'b1),
  .txclk_lp_n_i       (done_w ? lp_clk_n_w : 1'b1),
  .clk_lpen_i         (done_w ? lp_clk_en_w : 1'b1),
  .lp_direction_i     (),

  .dl1_txdata_lp_p_i  (done_w ? lp_data_p_w : 1'b1),
  .dl1_txdata_lp_n_i  (done_w ? lp_data_n_w : 1'b1),
  .dl0_txdata_lp_p_i  (lp_data_dcs_p_w),
  .dl0_txdata_lp_n_i  (lp_data_dcs_n_w),
  
  .dl1_txdata_lp_en_i (done_w ? lp_data_en_w : 1'b1),
  .dl0_txdata_lp_en_i (done_w ? lp_data_en_w : 1'b1),

  // Not use - in case to support bus turn-around
  .rxclk_lp_p_o       (),
  .rxclk_lp_n_o       (),
  .dl0_rxdata_lp_p_o  (),
  .dl0_rxdata_lp_n_o  ()
);

// Used to mimic DCS Transaction for CSI interface
csi2_inst_sig_delay sig_delay_inst(
  .clk      (pix_clk_i),
  .rstn     (pix_rstn),
  .in       (pll_lock_o),
  
  .out      (done_w)
);


  assign start_ptrn_gen = tinit_done_o;     // start when tinit_done_o is high

///////////////////////////////////////////////////////////////
// Tinit counter instance
///////////////////////////////////////////////////////////////
generate
if (TINIT_COUNT == "ON") begin: gen_tinit_count_on
csi2_inst_tinit_count tinit_count_inst(
  .clk          (core_clk_i),
  .resetn       (core_rstn),
  
  .tinit_done_o (tinit_done_o)
);



end
else begin: gen_tinit_count_off
  assign tinit_done_o = pll_lock_o;
end
endgenerate
// For internal use only. Not used as a feature of the soft IP.

endmodule
